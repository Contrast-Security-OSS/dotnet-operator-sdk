<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Webhooks | KubeOps Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Webhooks | KubeOps Documentation ">
    <meta name="generator" content="docfx 2.59.2.0">
    
    <link rel="shortcut icon" href="../images/favicon.png">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc">
    <meta property="docfx:tocrel" content="toc">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href="../docs/getting_started.html" title="Documentation">Documentation</a>
                      </li>
                      <li>
                          <a href="../kube-ops/index.html" title="KubeOps Api">KubeOps Api</a>
                      </li>
                      <li>
                          <a href="../kube-ops-testing/index.html" title="KubeOps Testing Api">KubeOps Testing Api</a>
                      </li>
                      <li>
                          <a href="https://github.com/buehler/dotnet-operator-sdk/releases" title="Changelog">Changelog</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <a href="getting_started.html" title="Getting Started" class="">Getting Started</a>
                    </li>
                    <li class="">
                      <a href="features.html" title="Features" class="">Features</a>
                    </li>
                    <li class="">
                      <a href="settings.html" title="Settings" class="">Settings</a>
                    </li>
                    <li class="">
                      <a href="entities.html" title="Entities" class="">Entities</a>
                    </li>
                    <li class="">
                      <a href="controller.html" title="Controller" class="">Controller</a>
                    </li>
                    <li class="">
                      <a href="events.html" title="Events" class="">Events</a>
                    </li>
                    <li class="">
                      <a href="finalizer.html" title="Finalizer" class="">Finalizer</a>
                    </li>
                    <li class="active">
                      <a href="webhooks.html" title="Webhooks" class="active">Webhooks</a>
                    </li>
                    <li class="">
                      <a href="utilities.html" title="Utilities" class="">Utilities</a>
                    </li>
                    <li class="">
                      <a href="commands.html" title="CLI Commands" class="">CLI Commands</a>
                    </li>
                    <li class="">
                      <a href="advanced.html" title="Advanced Topics" class="">Advanced Topics</a>
                    </li>
                    <li class="">
                      <a href="ms_build.html" title="MS Build extensions" class="">MS Build extensions</a>
                    </li>
                    <li class="">
                      <a href="testing.html" title="Testing" class="">Testing</a>
                    </li>
                    <li class="">
                      <a href="templates.html" title="Dotnet New Templates" class="">Dotnet New Templates</a>
                    </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="webhooks">Webhooks</h1>

<p>Kubernetes supports various webhooks to extend the normal api behaviour
of the master api. Those are documented on the
<a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">kubernetes website</a>.</p>
<p><code>KubeOps</code> supports the following webhooks out of the box:</p>
<ul>
<li>Validator / Validation</li>
<li>Mutator / Mutation</li>
</ul>
<p>The following documentation should give the user an overview
on how to implement a webhook what this implies to the written operator.</p>
<p>At the courtesy of the kubernetes website, here is a diagram of the
process that runs for admission controllers and api requests:</p>
<p><img src="https://d33wubrfki0l68.cloudfront.net/af21ecd38ec67b3d81c1b762221b4ac777fcf02d/7c60e/images/blog/2019-03-21-a-guide-to-kubernetes-admission-controllers/admission-controller-phases.png" alt="admission controller phases"></p>
<h2 id="general">General</h2>
<p>In general, if your operator contains <em>any</em> registered (registered in the
DI) the build process that is provided via <code>KubeOps.targets</code> will
generate a CA certificate for you.</p>
<p>So if you add a webhook to your operator the following changes
to the normal deployment of the operator will happen:</p>
<ol>
<li>During &quot;after build&quot; phase, the sdk will generate
a CA-certificate for self signed certificates for you.</li>
<li>The ca certificate and the corresponding key are added
to the deployment via kustomization config.</li>
<li>A special config is added to the deployment via
kustomization to use https.</li>
<li>The deployment of the operator now contains an <code>init-container</code>
that loads the <code>ca.pem</code> and <code>ca-key.pem</code> files and creates
a server certificate. Also, a service and the corresponding
webhook configurations are created.</li>
<li>When the operator starts, an additional https route is registered
with the created server certificate.</li>
</ol>
<p>When a webhook is registered, the specified operations will
trigger a POST call to the operator.</p>
<div class="NOTE"><h5>Note</h5><p>The certificates are generated with <a href="https://github.com/cloudflare/cfssl">cfssl</a>,
an amazing tool from cloudflare that helps with the general hassle
of creating CAs and certificates in general.</p>
</div>
<div class="NOTE"><h5>Note</h5><p>Make sure you commit the <code>ca.pem</code> / <code>ca-key.pem</code> file.
During operator startup (init container) those files
are needed. Since this represents a self signed certificate,
and it is only used for cluster internal communication,
it is no security issue to the system. The service is not
exposed to the internet.</p>
</div>
<div class="NOTE"><h5>Note</h5><p>The <code>server.pem</code> and <code>server-key.pem</code> files are generated
in the init container during pod startup.
Each pod / instance of the operator gets its own server
certificate but the CA must be shared among them.</p>
</div>
<h2 id="local-development">Local development</h2>
<p>It is possible to test / debug webhooks locally. For this, you need
to implement the webhook and use assembly-scanning (or the
operator builder if you disabled scanning) to register
the webhook type.</p>
<p>There are two possibilities to tell Kubernetes that it should
call your local running operator for the webhooks. The url
that Kubernetes addresses <em>must</em> be an HTTPS address.</p>
<h3 id="using-addwebhooklocaltunnel">Using <code>AddWebhookLocaltunnel</code></h3>
<p>In your <code>Startup.cs</code> you can use the <code>IOperatorBuilder</code>
method <code>AddWebhookLocaltunnel</code> to add an automatic
localtunnel instance to your operator.</p>
<p>This will cause the operator to register a hosted service that
creates a tunnel and then registers itself to Kubernetes
with the created proxy-url. Now all calls are automatically
forwarded via HTTPS to your operator.</p>
<pre><code class="lang-csharp">namespace KubeOps.TestOperator
{
    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services
               .AddKubernetesOperator()
#if DEBUG
               .AddWebhookLocaltunnel()
#endif
               ;
            services.AddTransient&lt;IManager, TestManager.TestManager&gt;();
        }

        public void Configure(IApplicationBuilder app)
        {
            app.UseKubernetesOperator();
        }
    }
}
</code></pre><div class="WARNING"><h5>Warning</h5><p>It is <em>strongly</em> advices against using auto-webhooks
with localtunnel in production. This feature
is intended to improve the developer experience
while coding operators.</p>
</div>
<div class="NOTE"><h5>Note</h5><p>Some IDEs (like Rider from JetBrains) do not correctly
terminate debugged applications. Hence, the
webhook registration remains in Kubernetes. If you remove
webhooks from your operator, you need to remove the
registration within Kubernetes as well.</p>
</div>
<h3 id="using-external-proxy">Using external proxy</h3>
<p>The operator will run on a specific http address, depending on your
configuration.
Now, use <a href="https://ngrok.com/">ngrok</a> or
<a href="https://localtunnel.github.io/www/">localtunnel</a> or something
similar to create a HTTPS tunnel to your local running operator.</p>
<p>Now you can use the cli command of the sdk
<code>dotnet run -- webhooks register --base-url &lt;&lt;TUNNEL URL&gt;&gt;</code> to
register the webhooks under the tunnel&#39;s url.</p>
<p>The result is your webhook being called by the kubernetes api.
It is suggested one uses <code>Docker Desktop</code> with kubernetes.</p>
<h2 id="validation-webhook">Validation webhook</h2>
<p>The general idea of this webhook type is to validate an entity
before it is definitely created / updated or deleted.</p>
<p>Webhooks are registered in a <strong>scoped</strong> manner to the DI system.
They behave like asp.net api controller.</p>
<p>The implementation of a validator is fairly simple:</p>
<ul>
<li>Create a class somewhere in your project.</li>
<li>Implement the <a class="xref" href="../kube-ops/KubeOps.Operator.Webhooks.IValidationWebhook-1.html">IValidationWebhook&lt;TEntity&gt;</a> interface.</li>
<li>Define the <a class="xref" href="../kube-ops/KubeOps.Operator.Webhooks.IAdmissionWebhook-2.html#KubeOps_Operator_Webhooks_IAdmissionWebhook_2_Operations">Operations</a>
(from the interface) that the validator is interested in.</li>
<li>Overwrite the corresponding methods.</li>
</ul>
<div class="WARNING"><h5>Warning</h5><p>The interface contains default implementations for <em>ALL</em> methods.
The default of the async methods are to call the sync ones.
The default of the sync methods is to return a &quot;not implemented&quot;
result.
The async methods take precedence over the synchronous ones.</p>
</div>
<p>The return value of the validation methods are
<a class="xref" href="../kube-ops/KubeOps.Operator.Webhooks.ValidationResult.html">ValidationResult</a>
objects. A result contains a boolean flag if the entity / operation
is valid or not. It may contain additional warnings (if it is valid)
that are presented to the user if the kubernetes api supports it.
If the result is invalid, one may add a custom http status code
as well as a custom error message that is presented to the user.</p>
<h3 id="example">Example</h3>
<pre><code class="lang-c#">public class TestValidator : IValidationWebhook&lt;EntityClass&gt;
 {
     public AdmissionOperations Operations =&gt; AdmissionOperations.Create | AdmissionOperations.Update;

     public ValidationResult Create(EntityClass newEntity, bool dryRun) =&gt;
         CheckSpec(newEntity)
             ? ValidationResult.Success(&quot;The username may not be foobar.&quot;)
             : ValidationResult.Fail(StatusCodes.Status400BadRequest, @&quot;Username is &quot;&quot;foobar&quot;&quot;.&quot;);

     public ValidationResult Update(EntityClass _, EntityClass newEntity, bool dryRun) =&gt;
         CheckSpec(newEntity)
             ? ValidationResult.Success(&quot;The username may not be foobar.&quot;)
             : ValidationResult.Fail(StatusCodes.Status400BadRequest, @&quot;Username is &quot;&quot;foobar&quot;&quot;.&quot;);

     private static bool CheckSpec(EntityClass entity) =&gt; entity.Spec.Username != &quot;foobar&quot;;
 }
</code></pre><h2 id="mutation-webhook">Mutation webhook</h2>
<p>Mutators are similar to validators but instead of defining if an object is
valid or not, they are able to modify an object on the fly. The result
of a mutator may generate a JSON Patch (<a href="http://jsonpatch.com">http://jsonpatch.com</a>) that patches
the object that is later passed to the validators and to the Kubernetes
API.</p>
<p>The implementation of a mutator is fairly simple:</p>
<ul>
<li>Create a class somewhere in your project.</li>
<li>Implement the <a class="xref" href="../kube-ops/KubeOps.Operator.Webhooks.IMutationWebhook-1.html">IMutationWebhook&lt;TEntity&gt;</a> interface.</li>
<li>Define the <a class="xref" href="../kube-ops/KubeOps.Operator.Webhooks.IAdmissionWebhook-2.html#KubeOps_Operator_Webhooks_IAdmissionWebhook_2_Operations">Operations</a>
(from the interface) that the validator is interested in.</li>
<li>Overwrite the corresponding methods.</li>
</ul>
<div class="WARNING"><h5>Warning</h5><p>The interface contains default implementations for <em>ALL</em> methods.
The default of the async methods are to call the sync ones.
The default of the sync methods is to return a &quot;not implemented&quot;
result.
The async methods take precedence over the synchronous ones.</p>
</div>
<p>The return value of the mutation methods do indicate if
there has been a change in the model or not. If there is no
change, return a result from <a class="xref" href="../kube-ops/KubeOps.Operator.Webhooks.MutationResult.html#KubeOps_Operator_Webhooks_MutationResult_NoChanges">NoChanges()</a>
and if there are changes, modify the object that is passed to the
method and return the changed object with
@&quot;KubeOps.Operator.Webhooks.MutationResult.Modified(System.Object)&quot;.
The system then calculates the diff and creates a JSON patch for
the object.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/Silvenga/dotnet-operator-sdk/blob/master/docs/docs/webhooks.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            © Copyright 2021 Christoph Bühler
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
